"""
MTGJSON sealed product and booster models.
"""

from __future__ import annotations

from typing import TYPE_CHECKING, Any, ClassVar

from pydantic import BaseModel, Field, model_validator

from mtgjson5.consts import ALLOW_IF_FALSEY

from .base import PolarsMixin
from .submodels import (
    BoosterConfig,
    BoosterPack,
    BoosterSheet,
    Identifiers,
    PurchaseUrls,
    SealedProductCard,
    SealedProductContents,
    SealedProductDeck,
    SealedProductOther,
    SealedProductPack,
    SealedProductSealed,
)

if TYPE_CHECKING:
    from polars import DataFrame


class SealedProduct(PolarsMixin, BaseModel):
    """Sealed product (booster box, bundle, etc.)."""

    model_config = {"populate_by_name": True}

    _allow_if_falsey: ClassVar[frozenset[str]] = (ALLOW_IF_FALSEY - {"language"}) | {"identifiers"}

    # --- Doc generation metadata ---
    __doc_title__: ClassVar[str] = "Sealed Product"
    __doc_desc__: ClassVar[str] = (
        "The Sealed Product Data Model describes the properties for the purchaseable product of a [Set](/data-models/set/) Data Model."
    )
    __doc_parent__: ClassVar[str] = (
        "**Parent model:** [Set](/data-models/set/), [Set List](/data-models/set-list/)\n"
        "- **Parent property:** `sealedProduct`"
    )
    __doc_enum__: ClassVar[str] = "sealedProduct"
    __doc_keywords__: ClassVar[str] = "mtg, magic the gathering, mtgjson, json, sealed product"

    uuid: str = Field(
        description="The universal unique identifier (v5) generated by MTGJSON.",
        json_schema_extra={"introduced": "v5.2.0"},
    )
    name: str = Field(
        description="The name of the product.",
        json_schema_extra={"introduced": "v5.2.0"},
    )
    category: str | None = Field(
        default=None,
        description="The category of this product.",
        json_schema_extra={"introduced": "v5.2.1", "optional": True},
    )
    set_code: str | None = Field(default=None, alias="setCode")
    subtype: str | None = Field(
        default=None,
        description="The category subtype of this product.",
        json_schema_extra={"introduced": "v5.2.1"},
    )
    language: str | None = None
    release_date: str | None = Field(
        default=None,
        alias="releaseDate",
        description=(
            "The release date in "
            "[ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) "
            "format for the product. Not included if the set was not formally released as a product."
        ),
        json_schema_extra={"introduced": "v5.2.0", "optional": True},
    )
    card_count: int | None = Field(
        default=None,
        alias="cardCount",
        description="The number of cards in this product.",
        json_schema_extra={"introduced": "v5.2.2", "optional": True},
    )
    product_size: int | None = Field(
        default=None,
        alias="productSize",
        description="The size of the product.",
        json_schema_extra={"introduced": "v5.2.1", "optional": True},
    )
    contents: SealedProductContents | None = Field(
        default=None,
        description="The contents of this product. See the [Sealed Product Contents](/data-models/sealed-product/sealed-product-contents/) Data Model.",
        json_schema_extra={"introduced": "v5.2.2", "optional": True},
    )
    identifiers: Identifiers = Field(
        default_factory=dict,  # type: ignore[assignment]
        description="The identifiers associated to a product. See the [Identifiers](/data-models/identifiers/) Data Model.",
        json_schema_extra={"introduced": "v5.2.0"},
    )
    purchase_urls: PurchaseUrls = Field(
        default_factory=dict,  # type: ignore[assignment]
        alias="purchaseUrls",
        description="Links that navigate to websites where the product can be purchased. See the [Purchase Urls](/data-models/purchase-urls/) Data Model.",
        json_schema_extra={"introduced": "v5.2.0"},
    )

    @model_validator(mode="before")
    @classmethod
    def populate_finishes_from_foil(cls, data: Any) -> Any:
        """Populate finishes field from foil boolean for sealed product cards."""
        if isinstance(data, dict) and "contents" in data:
            contents = data["contents"]
            if isinstance(contents, dict) and "card" in contents:
                for card in contents["card"]:
                    if isinstance(card, dict) and "finishes" not in card:
                        card["finishes"] = ["foil"] if card.get("foil") else ["nonfoil"]
        return data


class SealedProductAssembler:
    """Assembles SealedProduct objects from DataFrames."""

    @staticmethod
    def from_dataframe(df: DataFrame) -> list[dict[str, Any]]:
        """Convert sealed products DataFrame to list of dicts."""
        models = SealedProduct.from_dataframe(df)
        return [m.to_polars_dict(exclude_none=True) for m in models]

    @staticmethod
    def assemble_contents(
        contents_df: DataFrame,
        product_uuid: str,
    ) -> SealedProductContents:
        """
        Assemble contents struct for a single product.

        Args:
            contents_df: Contents DataFrame with contentType column
            product_uuid: Product UUID to filter by

        Returns:
            SealedProductContents TypedDict
        """
        try:
            import polars as pl
        except ImportError as err:
            raise ImportError("Polars required") from err

        filtered = contents_df.filter(pl.col("productUuid") == product_uuid)

        contents: SealedProductContents = {}

        for content_type in ["card", "deck", "other", "pack", "sealed"]:
            type_rows = filtered.filter(pl.col("contentType") == content_type)
            if len(type_rows) == 0:
                continue

            if content_type == "card":
                contents["card"] = [
                    SealedProductCard(
                        uuid=r["uuid"],
                        name=r["name"],
                        number=r["number"],
                        set=r["set"],
                        foil=r.get("foil"),
                        finishes=["foil"] if r.get("foil") else ["nonfoil"],
                    )
                    for r in type_rows.to_dicts()
                ]
            elif content_type == "sealed":
                contents["sealed"] = [
                    SealedProductSealed(
                        uuid=r["uuid"],
                        name=r["name"],
                        set=r["set"],
                        count=r.get("count", 1),
                    )
                    for r in type_rows.to_dicts()
                ]
            elif content_type == "deck":
                contents["deck"] = [SealedProductDeck(name=r["name"], set=r["set"]) for r in type_rows.to_dicts()]
            elif content_type == "pack":
                contents["pack"] = [SealedProductPack(code=r["code"], set=r["set"]) for r in type_rows.to_dicts()]
            elif content_type == "other":
                contents["other"] = [SealedProductOther(name=r["name"]) for r in type_rows.to_dicts()]

        return contents


class BoosterAssembler:
    """Assembles booster configurations from card/sheet data."""

    def __init__(self, cards_df: DataFrame):
        """
        Args:
            cards_df: DataFrame with card data including boosterTypes, uuid
        """
        self.cards_df = cards_df

    def build_sheet(
        self,
        sheet_name: str,
        card_uuids: list[str],
        weights: list[int] | None = None,
        foil: bool = False,
        balance_colors: bool = False,
        allow_duplicates: bool = False,
        fixed: bool = False,
    ) -> BoosterSheet:
        """
        Build a single booster sheet.

        Args:
            sheet_name: Name of the sheet
            card_uuids: List of card UUIDs in the sheet
            weights: Optional weights per card (defaults to 1 each)
            foil: Whether cards from this sheet are foil
            balance_colors: Whether to balance colors when picking
            allow_duplicates: Whether duplicates are allowed
            fixed: Whether this is a fixed sheet

        Returns:
            BoosterSheet TypedDict
        """
        if weights is None:
            weights = [1] * len(card_uuids)

        cards = dict(zip(card_uuids, weights, strict=False))
        total_weight = sum(weights)

        sheet: BoosterSheet = {
            "cards": cards,
            "foil": foil,
            "totalWeight": total_weight,
        }

        if allow_duplicates:
            sheet["allowDuplicates"] = True
        if balance_colors:
            sheet["balanceColors"] = True
        if fixed:
            sheet["fixed"] = True

        return sheet

    def build_sheet_from_df(
        self,
        sheet_name: str,
        filter_expr: Any,  # pl.Expr
        foil: bool = False,
        weight_col: str | None = None,
        **kwargs: Any,
    ) -> BoosterSheet:
        """
        Build a sheet from a filtered DataFrame.

        Args:
            sheet_name: Name of the sheet
            filter_expr: Polars filter expression
            foil: Whether cards are foil
            weight_col: Optional column for weights
            **kwargs: Additional sheet options

        Returns:
            BoosterSheet TypedDict
        """
        filtered = self.cards_df.filter(filter_expr)

        uuids = filtered["uuid"].to_list()
        weights = None
        if weight_col and weight_col in filtered.columns:
            weights = filtered[weight_col].to_list()

        return self.build_sheet(sheet_name, uuids, weights, foil=foil, **kwargs)

    def build_pack(
        self,
        contents: dict[str, int],
        weight: int = 1,
    ) -> BoosterPack:
        """
        Build a booster pack configuration.

        Args:
            contents: Mapping of sheet_name -> count
            weight: Weight of this pack variant

        Returns:
            BoosterPack TypedDict
        """
        return {"contents": contents, "weight": weight}

    def build_config(
        self,
        sheets: dict[str, BoosterSheet],
        packs: list[BoosterPack],
        source_set_codes: list[str],
        name: str | None = None,
    ) -> BoosterConfig:
        """
        Build a complete booster configuration.

        Args:
            sheets: Mapping of sheet_name -> BoosterSheet
            packs: List of pack configurations
            source_set_codes: Set codes that cards come from
            name: Optional name for this booster type

        Returns:
            BoosterConfig TypedDict
        """
        total_weight = sum(p["weight"] for p in packs)

        config: BoosterConfig = {
            "boosters": packs,
            "boostersTotalWeight": total_weight,
            "sheets": sheets,
            "sourceSetCodes": sorted(source_set_codes),
        }

        if name:
            config["name"] = name

        return config

    @classmethod
    def build_draft_booster(
        cls,
        cards_df: DataFrame,
        set_code: str,
    ) -> BoosterConfig:
        """
        Build a standard draft booster configuration.

        Typical structure:
        - 1 rare/mythic
        - 3 uncommons
        - 10 commons
        - 1 basic land (or foil)

        Args:
            cards_df: DataFrame with cards for the set
            set_code: Set code

        Returns:
            BoosterConfig for draft boosters
        """
        try:
            import polars as pl
        except ImportError as err:
            raise ImportError("Polars required") from err

        assembler = cls(cards_df)

        # Build sheets by rarity
        sheets: dict[str, BoosterSheet] = {}

        # Mythics (weight 1) and rares (weight 2) combined
        mythics = cards_df.filter(pl.col("rarity") == "mythic")["uuid"].to_list()
        rares = cards_df.filter(pl.col("rarity") == "rare")["uuid"].to_list()

        rare_mythic_cards = dict.fromkeys(mythics, 1)
        rare_mythic_cards.update(dict.fromkeys(rares, 2))

        if rare_mythic_cards:
            sheets["rareMythic"] = {
                "cards": rare_mythic_cards,
                "foil": False,
                "totalWeight": sum(rare_mythic_cards.values()),
            }

        # Uncommons
        uncommons = cards_df.filter(pl.col("rarity") == "uncommon")["uuid"].to_list()
        if uncommons:
            sheets["uncommon"] = assembler.build_sheet("uncommon", uncommons)

        # Commons
        commons = cards_df.filter(pl.col("rarity") == "common")["uuid"].to_list()
        if commons:
            sheets["common"] = assembler.build_sheet("common", commons)

        # Basic lands
        basics = cards_df.filter(pl.col("supertypes").list.contains("Basic") & pl.col("types").list.contains("Land"))[
            "uuid"
        ].to_list()
        if basics:
            sheets["basicLand"] = assembler.build_sheet("basicLand", basics)

        # Standard pack: 1R/M, 3U, 10C, 1L
        pack_contents = {}
        if "rareMythic" in sheets:
            pack_contents["rareMythic"] = 1
        if "uncommon" in sheets:
            pack_contents["uncommon"] = 3
        if "common" in sheets:
            pack_contents["common"] = 10
        if "basicLand" in sheets:
            pack_contents["basicLand"] = 1

        packs = [assembler.build_pack(pack_contents)]

        return assembler.build_config(
            sheets=sheets,
            packs=packs,
            source_set_codes=[set_code],
            name="draft",
        )

    @staticmethod
    def from_json(data: dict[str, Any]) -> dict[str, BoosterConfig]:
        """
        Parse booster configs from JSON (e.g., from set data).

        Args:
            data: Booster data dict from set JSON

        Returns:
            Dict of booster_type -> BoosterConfig
        """
        # Already in correct format, just validate structure
        result: dict[str, BoosterConfig] = {}

        for booster_type, config in data.items():
            result[booster_type] = BoosterConfig(
                boosters=config.get("boosters", []),
                boostersTotalWeight=config.get("boostersTotalWeight", 0),
                sheets=config.get("sheets", {}),
                sourceSetCodes=config.get("sourceSetCodes", []),
                name=config.get("name"),
            )

        return result


class Sealed:
    """Namespace for all sealed product models."""

    SealedProduct = SealedProduct


SEALED_MODEL_REGISTRY: list[type[BaseModel]] = [
    SealedProduct,
]

__all__ = [
    "SEALED_MODEL_REGISTRY",
    "Sealed",
]
